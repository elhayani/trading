ython# Ce que vous rÃ©cupÃ©rez dÃ©jÃ  avec fetch_ohlcv()
[
    timestamp,    # 0
    open,        # 1
    high,        # 2
    low,         # 3
    close,       # 4
    volume,      # 5
    close_time,  # 6
    quote_volume,# 7 â† IMPORTANT !
    trades,      # 8 â† Nombre de trades
    taker_buy_base,  # 9
    taker_buy_quote, # 10
    ignore       # 11
]
2. DONNÃ‰ES TICKER 24h (Endpoint /ticker/24hr)
pythondef fetch_binance_ticker_stats(self, symbol: str) -> Dict:
    """
    RÃ©cupÃ¨re les statistiques 24h de Binance
    BEAUCOUP plus d'infos que fetch_ticker() standard
    """
    try:
        ticker = self.exchange.fetch_ticker(symbol)
        
        # DonnÃ©es disponibles :
        return {
            'symbol': symbol,
            'price': ticker['last'],
            'volume_24h': ticker['quoteVolume'],  # Volume en USDT
            'volume_base_24h': ticker['baseVolume'],  # Volume en crypto
            'price_change_24h_pct': ticker['percentage'],
            'high_24h': ticker['high'],
            'low_24h': ticker['low'],
            'trades_count_24h': ticker['info'].get('count', 0),  # Nombre de trades
            'bid': ticker['bid'],
            'ask': ticker['ask'],
            'bid_volume': ticker['bidVolume'],
            'ask_volume': ticker['askVolume'],
            'weighted_avg_price': float(ticker['info'].get('weightedAvgPrice', 0)),  # VWAP 24h !
            'prev_close': float(ticker['info'].get('prevClosePrice', 0)),
            'open_price': ticker['open']
        }
    except Exception as e:
        logger.error(f"Failed to fetch ticker stats: {e}")
        return {}
3. ORDER BOOK (Profondeur de marchÃ©)
pythondef fetch_order_book_analysis(self, symbol: str, limit: int = 100) -> Dict:
    """
    Analyse du carnet d'ordres (Order Book)
    EXCELLENT pour dÃ©tecter les murs d'achat/vente
    """
    try:
        orderbook = self.exchange.fetch_order_book(symbol, limit=limit)
        
        bids = orderbook['bids']  # [[price, quantity], ...]
        asks = orderbook['asks']
        
        # Calculs avancÃ©s
        total_bid_volume = sum([bid[1] for bid in bids])
        total_ask_volume = sum([ask[1] for ask in asks])
        
        # Prix pondÃ©rÃ©s
        bid_weighted = sum([bid[0] * bid[1] for bid in bids]) / total_bid_volume if total_bid_volume > 0 else 0
        ask_weighted = sum([ask[0] * ask[1] for ask in asks]) / total_ask_volume if total_ask_volume > 0 else 0
        
        # Spread
        spread = (asks[0][0] - bids[0][0]) / bids[0][0] * 100
        
        # DÃ©sÃ©quilibre (Buy pressure)
        imbalance = (total_bid_volume - total_ask_volume) / (total_bid_volume + total_ask_volume)
        
        # DÃ©tection de murs (Wall detection)
        avg_bid_size = total_bid_volume / len(bids)
        avg_ask_size = total_ask_volume / len(asks)
        
        buy_walls = [bid for bid in bids if bid[1] > avg_bid_size * 5]  # 5x la moyenne
        sell_walls = [ask for ask in asks if ask[1] > avg_ask_size * 5]
        
        return {
            'bid_volume': total_bid_volume,
            'ask_volume': total_ask_volume,
            'imbalance': imbalance,  # +1 = acheteurs dominent, -1 = vendeurs
            'spread_pct': spread,
            'bid_weighted_price': bid_weighted,
            'ask_weighted_price': ask_weighted,
            'buy_walls_count': len(buy_walls),
            'sell_walls_count': len(sell_walls),
            'biggest_buy_wall': max([w[1] for w in buy_walls], default=0),
            'biggest_sell_wall': max([w[1] for w in sell_walls], default=0)
        }
    except Exception as e:
        logger.error(f"Failed to fetch orderbook: {e}")
        return {}
4. TRADES RÃ‰CENTS (AggressivitÃ©)
pythondef fetch_recent_trades_analysis(self, symbol: str, limit: int = 500) -> Dict:
    """
    Analyse des trades rÃ©cents
    DÃ©tecte l'aggressivitÃ© des acheteurs vs vendeurs
    """
    try:
        trades = self.exchange.fetch_trades(symbol, limit=limit)
        
        # SÃ©paration market buys vs market sells
        buys = [t for t in trades if t['side'] == 'buy']
        sells = [t for t in trades if t['side'] == 'sell']
        
        buy_volume = sum([t['amount'] * t['price'] for t in buys])
        sell_volume = sum([t['amount'] * t['price'] for t in sells])
        
        # AggressivitÃ© = ratio des trades market
        aggression = (buy_volume - sell_volume) / (buy_volume + sell_volume) if (buy_volume + sell_volume) > 0 else 0
        
        # Taille moyenne des trades
        avg_buy_size = buy_volume / len(buys) if buys else 0
        avg_sell_size = sell_volume / len(sells) if sells else 0
        
        # Gros trades (whales)
        total_volume = buy_volume + sell_volume
        avg_trade_size = total_volume / len(trades)
        whale_trades = [t for t in trades if (t['amount'] * t['price']) > avg_trade_size * 10]
        
        return {
            'buy_volume': buy_volume,
            'sell_volume': sell_volume,
            'aggression': aggression,  # +1 = acheteurs agressifs, -1 = vendeurs
            'avg_buy_size': avg_buy_size,
            'avg_sell_size': avg_sell_size,
            'whale_trades_count': len(whale_trades),
            'whale_ratio': len(whale_trades) / len(trades) if trades else 0
        }
    except Exception as e:
        logger.error(f"Failed to fetch trades: {e}")
        return {}
5. FUNDING RATE (Futures uniquement)
pythondef fetch_funding_rate(self, symbol: str) -> Dict:
    """
    Taux de financement (Futures)
    CRITIQUE pour dÃ©tecter les positions extrÃªmes
    """
    try:
        # Binance Futures API
        funding = self.exchange.fetch_funding_rate(symbol)
        
        return {
            'funding_rate': funding['fundingRate'],  # Positif = longs paient shorts
            'funding_timestamp': funding['fundingTimestamp'],
            'next_funding_time': funding['info'].get('nextFundingTime'),
            
            # InterprÃ©tation
            'sentiment': 'BULLISH' if funding['fundingRate'] > 0.0001 else 'BEARISH' if funding['fundingRate'] < -0.0001 else 'NEUTRAL'
        }
    except Exception as e:
        logger.warning(f"Funding rate not available for {symbol}: {e}")
        return {}
6. OPEN INTEREST (Futures)
pythondef fetch_open_interest(self, symbol: str) -> Dict:
    """
    Open Interest = Positions ouvertes totales
    Augmentation OI + Prix hausse = Bullish fort
    Diminution OI + Prix hausse = Short squeeze / Bearish
    """
    try:
        oi = self.exchange.fetch_open_interest(symbol)
        
        return {
            'open_interest': oi['openInterest'],
            'timestamp': oi['timestamp']
        }
    except Exception as e:
        logger.warning(f"OI not available: {e}")
        return {}

ðŸŽ¯ INDICATEURS CALCULABLES Ã€ PARTIR DES DONNÃ‰ES BINANCE
Nouveau fichier : binance_metrics.py
python"""
Indicateurs calculÃ©s Ã  partir des donnÃ©es natives Binance
Pas besoin de TA-Lib ou de calculs complexes
"""

import pandas as pd
import numpy as np
from typing import Dict, List
import logging

logger = logging.getLogger(__name__)

class BinanceMetrics:
    """Calcule des mÃ©triques avancÃ©es Ã  partir des donnÃ©es Binance brutes"""
    
    @staticmethod
    def calculate_volume_profile(ohlcv: List, bins: int = 20) -> Dict:
        """
        Volume Profile (POC - Point of Control)
        Identifie les niveaux de prix avec le plus de volume
        """
        df = pd.DataFrame(ohlcv, columns=['ts', 'o', 'h', 'l', 'c', 'v', 'ct', 'qv', 'trades', 'tbbv', 'tbqv', 'ignore'])
        
        price_min = df['l'].min()
        price_max = df['h'].max()
        price_bins = np.linspace(price_min, price_max, bins)
        
        volume_at_price = {}
        for idx, row in df.iterrows():
            # Distribuer le volume sur la range high-low
            bin_idx = np.digitize((row['h'] + row['l']) / 2, price_bins)
            volume_at_price[bin_idx] = volume_at_price.get(bin_idx, 0) + row['v']
        
        # POC = prix avec le plus de volume
        poc_bin = max(volume_at_price, key=volume_at_price.get)
        poc_price = price_bins[poc_bin]
        
        # Value Area (70% du volume)
        sorted_bins = sorted(volume_at_price.items(), key=lambda x: x[1], reverse=True)
        total_volume = sum(volume_at_price.values())
        va_volume = 0
        va_bins = []
        
        for bin_idx, vol in sorted_bins:
            va_bins.append(bin_idx)
            va_volume += vol
            if va_volume >= total_volume * 0.7:
                break
        
        va_high = price_bins[max(va_bins)]
        va_low = price_bins[min(va_bins)]
        
        return {
            'poc': poc_price,  # Point of Control (prix avec max volume)
            'va_high': va_high,  # Value Area High
            'va_low': va_low,    # Value Area Low
            'current_vs_poc': (df.iloc[-1]['c'] - poc_price) / poc_price * 100
        }
    
    @staticmethod
    def calculate_delta_volume(ohlcv: List) -> Dict:
        """
        Delta Volume = DiffÃ©rence entre volume des bougies vertes et rouges
        Positif = pression acheteuse, NÃ©gatif = pression vendeuse
        """
        df = pd.DataFrame(ohlcv, columns=['ts', 'o', 'h', 'l', 'c', 'v', 'ct', 'qv', 'trades', 'tbbv', 'tbqv', 'ignore'])
        
        df['bullish'] = df['c'] > df['o']
        
        bull_volume = df[df['bullish']]['v'].sum()
        bear_volume = df[~df['bullish']]['v'].sum()
        
        delta = bull_volume - bear_volume
        delta_pct = delta / (bull_volume + bear_volume) * 100 if (bull_volume + bear_volume) > 0 else 0
        
        # Delta cumulatif (CVD - Cumulative Volume Delta)
        df['delta'] = np.where(df['bullish'], df['v'], -df['v'])
        cvd = df['delta'].cumsum()
        
        # Tendance du CVD
        cvd_slope = (cvd.iloc[-1] - cvd.iloc[-20]) / 20 if len(cvd) >= 20 else 0
        
        return {
            'delta': delta,
            'delta_pct': delta_pct,
            'bull_volume': bull_volume,
            'bear_volume': bear_volume,
            'cvd': cvd.iloc[-1],
            'cvd_trend': 'BULLISH' if cvd_slope > 0 else 'BEARISH',
            'cvd_strength': abs(cvd_slope)
        }
    
    @staticmethod
    def calculate_buy_sell_ratio(ohlcv: List) -> Dict:
        """
        Ratio Taker Buy / Taker Sell
        taker_buy_base_volume (index 9) vs volume total
        """
        df = pd.DataFrame(ohlcv, columns=['ts', 'o', 'h', 'l', 'c', 'v', 'ct', 'qv', 'trades', 'tbbv', 'tbqv', 'ignore'])
        
        # taker_buy_base_volume = volume des market buys (acheteurs agressifs)
        total_taker_buy = df['tbbv'].sum()
        total_volume = df['v'].sum()
        
        taker_sell = total_volume - total_taker_buy
        
        ratio = total_taker_buy / taker_sell if taker_sell > 0 else 1.0
        buy_pct = total_taker_buy / total_volume * 100 if total_volume > 0 else 50
        
        # Tendance rÃ©cente (10 derniÃ¨res bougies)
        recent_buy = df.tail(10)['tbbv'].sum()
        recent_total = df.tail(10)['v'].sum()
        recent_buy_pct = recent_buy / recent_total * 100 if recent_total > 0 else 50
        
        return {
            'buy_sell_ratio': ratio,
            'buy_percentage': buy_pct,
            'recent_buy_percentage': recent_buy_pct,
            'pressure': 'BUY' if buy_pct > 55 else 'SELL' if buy_pct < 45 else 'NEUTRAL',
            'acceleration': recent_buy_pct - buy_pct  # Tendance rÃ©cente vs globale
        }
    
    @staticmethod
    def calculate_trade_intensity(ohlcv: List) -> Dict:
        """
        IntensitÃ© des trades (nombre de trades vs volume)
        Beaucoup de trades + peu de volume = Retail
        Peu de trades + gros volume = Whales
        """
        df = pd.DataFrame(ohlcv, columns=['ts', 'o', 'h', 'l', 'c', 'v', 'ct', 'qv', 'trades', 'tbbv', 'tbqv', 'ignore'])
        
        avg_trade_size = df['v'] / df['trades']
        
        # Identifier les bougies avec gros trades (whales)
        whale_threshold = avg_trade_size.mean() * 3
        whale_candles = df[avg_trade_size > whale_threshold]
        
        # FrÃ©quence des trades
        trades_per_minute = df['trades'].mean()
        
        return {
            'avg_trade_size': avg_trade_size.mean(),
            'whale_activity': len(whale_candles) / len(df) * 100,
            'trades_per_candle': df['trades'].mean(),
            'market_type': 'WHALE_DRIVEN' if len(whale_candles) / len(df) > 0.2 else 'RETAIL_DRIVEN'
        }
    
    @staticmethod
    def calculate_volatility_regime(ohlcv: List) -> Dict:
        """
        RÃ©gime de volatilitÃ© basÃ© sur True Range
        """
        df = pd.DataFrame(ohlcv, columns=['ts', 'o', 'h', 'l', 'c', 'v', 'ct', 'qv', 'trades', 'tbbv', 'tbqv', 'ignore'])
        
        # True Range
        df['tr'] = df[['h', 'l', 'c']].apply(
            lambda x: max(x['h'] - x['l'], abs(x['h'] - x['c']), abs(x['l'] - x['c'])), axis=1
        )
        
        atr = df['tr'].rolling(14).mean()
        current_atr = atr.iloc[-1]
        avg_atr = atr.mean()
        
        # Volatility percentile
        volatility_rank = (current_atr > atr).sum() / len(atr) * 100
        
        return {
            'current_atr': current_atr,
            'avg_atr': avg_atr,
            'atr_ratio': current_atr / avg_atr if avg_atr > 0 else 1.0,
            'volatility_percentile': volatility_rank,
            'regime': 'LOW' if volatility_rank < 25 else 'HIGH' if volatility_rank > 75 else 'NORMAL'
        }
    
    @staticmethod
    def calculate_momentum_shift(ohlcv: List) -> Dict:
        """
        DÃ©tection de changement de momentum
        BasÃ© sur l'accÃ©lÃ©ration du prix et du volume
        """
        df = pd.DataFrame(ohlcv, columns=['ts', 'o', 'h', 'l', 'c', 'v', 'ct', 'qv', 'trades', 'tbbv', 'tbqv', 'ignore'])
        
        # ROC (Rate of Change) sur diffÃ©rentes pÃ©riodes
        roc_5 = (df['c'].iloc[-1] - df['c'].iloc[-6]) / df['c'].iloc[-6] * 100 if len(df) > 5 else 0
        roc_20 = (df['c'].iloc[-1] - df['c'].iloc[-21]) / df['c'].iloc[-21] * 100 if len(df) > 20 else 0
        
        # Volume ROC
        vol_current = df.tail(5)['v'].mean()
        vol_baseline = df.tail(20)['v'].mean()
        vol_increase = (vol_current - vol_baseline) / vol_baseline * 100 if vol_baseline > 0 else 0
        
        # AccÃ©lÃ©ration
        acceleration = roc_5 - roc_20
        
        return {
            'roc_5': roc_5,
            'roc_20': roc_20,
            'acceleration': acceleration,
            'volume_increase': vol_increase,
            'shift_detected': abs(acceleration) > 2 and vol_increase > 30,
            'direction': 'BULLISH' if acceleration > 0 else 'BEARISH'
        }

ðŸš€ SCANNER OPTIMISÃ‰ AVEC DONNÃ‰ES BINANCE NATIVES
python# binance_scanner.py

from typing import Dict, List
import logging
from exchange_connector import ExchangeConnector
from binance_metrics import BinanceMetrics

logger = logging.getLogger(__name__)

class BinanceNativeScanner:
    """
    Scanner utilisant UNIQUEMENT les donnÃ©es natives Binance
    Pas de TA-Lib, pas de calculs complexes
    """
    
    def __init__(self, exchange: ExchangeConnector):
        self.exchange = exchange
        self.metrics = BinanceMetrics()
    
    def score_symbol_binance_native(self, symbol: str) -> Dict:
        """
        Score basÃ© uniquement sur les donnÃ©es Binance
        """
        try:
            # 1. OHLCV (avec toutes les colonnes)
            ohlcv = self.exchange.fetch_ohlcv(symbol, '1h', limit=100)
            
            # 2. Ticker 24h
            ticker = self.exchange.fetch_ticker(symbol)
            
            # 3. Order Book
            orderbook_analysis = self.fetch_order_book_analysis(symbol, limit=50)
            
            # 4. Trades rÃ©cents
            trades_analysis = self.fetch_recent_trades_analysis(symbol, limit=200)
            
            # ========== CALCUL DES MÃ‰TRIQUES ==========
            
            volume_profile = self.metrics.calculate_volume_profile(ohlcv)
            delta = self.metrics.calculate_delta_volume(ohlcv)
            buy_sell = self.metrics.calculate_buy_sell_ratio(ohlcv)
            intensity = self.metrics.calculate_trade_intensity(ohlcv)
            volatility = self.metrics.calculate_volatility_regime(ohlcv)
            momentum = self.metrics.calculate_momentum_shift(ohlcv)
            
            # ========== SCORING ==========
            
            score = 0
            signals = []
            direction = None
            
            # 1. MOMENTUM (25 points)
            if momentum['shift_detected']:
                score += 25
                signals.append(f"MOMENTUM_SHIFT_{momentum['direction']}")
                direction = 'LONG' if momentum['direction'] == 'BULLISH' else 'SHORT'
            elif abs(momentum['acceleration']) > 1:
                score += 15
                signals.append("MOMENTUM_BUILD")
            
            # 2. BUY/SELL PRESSURE (20 points)
            if buy_sell['buy_percentage'] > 60:
                score += 20
                signals.append("STRONG_BUY_PRESSURE")
                if direction != 'SHORT': direction = 'LONG'
            elif buy_sell['buy_percentage'] < 40:
                score += 20
                signals.append("STRONG_SELL_PRESSURE")
                if direction != 'LONG': direction = 'SHORT'
            elif buy_sell['buy_percentage'] > 55:
                score += 10
                signals.append("MODERATE_BUY")
            
            # 3. DELTA VOLUME (20 points)
            if delta['delta_pct'] > 30:
                score += 20
                signals.append("BULLISH_DELTA")
                if direction != 'SHORT': direction = 'LONG'
            elif delta['delta_pct'] < -30:
                score += 20
                signals.append("BEARISH_DELTA")
                if direction != 'LONG': direction = 'SHORT'
            
            # 4. ORDER BOOK IMBALANCE (15 points)
            if orderbook_analysis.get('imbalance', 0) > 0.3:
                score += 15
                signals.append("ORDERBOOK_BUY_PRESSURE")
                if direction != 'SHORT': direction = 'LONG'
            elif orderbook_analysis.get('imbalance', 0) < -0.3:
                score += 15
                signals.append("ORDERBOOK_SELL_PRESSURE")
                if direction != 'LONG': direction = 'SHORT'
            
            # 5. WHALE ACTIVITY (10 points)
            if intensity['whale_activity'] > 20:
                score += 10
                signals.append("WHALE_ACTIVE")
            
            # 6. VOLATILITY (10 points)
            if volatility['regime'] == 'NORMAL':
                score += 10
                signals.append("IDEAL_VOLATILITY")
            elif volatility['regime'] == 'LOW':
                score += 5
                signals.append("LOW_VOLATILITY_SQUEEZE")
            
            # 7. PRICE VS POC (10 points)
            poc_distance = volume_profile['current_vs_poc']
            if abs(poc_distance) < 1:  # Prix proche du POC (support fort)
                score += 10
                signals.append("NEAR_POC_SUPPORT")
            
            # 8. RECENT TRADES AGGRESSION (10 points)
            if trades_analysis.get('aggression', 0) > 0.4:
                score += 10
                signals.append("AGGRESSIVE_BUYERS")
                if direction != 'SHORT': direction = 'LONG'
            elif trades_analysis.get('aggression', 0) < -0.4:
                score += 10
                signals.append("AGGRESSIVE_SELLERS")
                if direction != 'LONG': direction = 'SHORT'
            
            # BONUS: Convergence totale
            if len(signals) >= 5:
                score += 10
                signals.append("MULTI_CONFIRMATION")
            
            return {
                'symbol': symbol,
                'score': min(score, 100),
                'direction': direction or 'NEUTRAL',
                'signals': signals,
                'metrics': {
                    'price_change_24h': ticker.get('percentage', 0),
                    'volume_24h_usdt': ticker.get('quoteVolume', 0),
                    'buy_pressure': buy_sell['buy_percentage'],
                    'delta_pct': delta['delta_pct'],
                    'orderbook_imbalance': orderbook_analysis.get('imbalance', 0),
                    'whale_activity': intensity['whale_activity'],
                    'volatility': volatility['regime'],
                    'poc_distance': poc_distance,
                    'momentum_shift': momentum['shift_detected']
                },
                'price': ticker['last']
            }
            
        except Exception as e:
            logger.error(f"Failed to score {symbol}: {e}")
            return {'symbol': symbol, 'score': 0, 'error': str(e)}
    
    # ... (ajouter les mÃ©thodes fetch_order_book_analysis et fetch_recent_trades_analysis ici)

ðŸ“Š TOP 10 INDICATEURS BINANCE NATIFS
IndicateurSourceFiabilitÃ©UtilitÃ©CalculTaker Buy RatioOHLCV[9]â­â­â­â­â­Pression achat/ventetaker_buy_volume / total_volumeDelta VolumeOHLCVâ­â­â­â­â­Direction momentumbull_candles_vol - bear_candles_volOrder Book Imbalance/depthâ­â­â­â­â­Pression immÃ©diate(bid_vol - ask_vol) / totalVolume Profile POCOHLCVâ­â­â­â­Support/RÃ©sistanceDistribution volume par prixTrade IntensityOHLCV[8]â­â­â­â­Whale detectionvolume / trades_countRecent Trades Aggression/tradesâ­â­â­â­Sentiment temps rÃ©elmarket_buys - market_sellsVWAP 24hTickerâ­â­â­â­Prix institutionnelBinance le calcule !Funding RateFuturesâ­â­â­â­â­Sentiment positionsAPI /fundingRateOpen InterestFuturesâ­â­â­â­Force tendanceAPI /openInterestSpread %Order Bookâ­â­â­LiquiditÃ©(ask - bid) / bid

âœ… RECOMMANDATION FINALE
Pour vos 415 actifs, utilisez ce pipeline:

Fetch rapide (ticker 24h) â†’ Filtre volume > $1M
OHLCV complet â†’ Delta Volume + Buy/Sell Ratio
Order Book â†’ Imbalance (top 50 seulement)
Trades rÃ©cents â†’ Aggression (top 20 seulement)